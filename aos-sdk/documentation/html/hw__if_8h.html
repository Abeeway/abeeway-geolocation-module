<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Abeeway Geolocation Module SDK: aos-libs/aos-core/aos_ble/hw_if.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Abeeway Geolocation Module SDK
   </div>
   <div id="projectbrief">A FreeRTOS based Software Development Kit for the Abeeway Geolocation Module</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_bbd625c80d66cf6285b9f7aba4ae7f44.html">aos-libs</a></li><li class="navelem"><a class="el" href="dir_9b4042f62b6e2c6c9d31918830fb9c1c.html">aos-core</a></li><li class="navelem"><a class="el" href="dir_1aa8bfd52cad26cb00cfb3308833701e.html">aos_ble</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">hw_if.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Hardware Interface.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;stm32wbxx.h&quot;</code><br />
<code>#include &quot;stm32wbxx_ll_exti.h&quot;</code><br />
<code>#include &quot;stm32wbxx_ll_system.h&quot;</code><br />
<code>#include &quot;stm32wbxx_ll_rcc.h&quot;</code><br />
<code>#include &quot;stm32wbxx_ll_ipcc.h&quot;</code><br />
<code>#include &quot;stm32wbxx_ll_bus.h&quot;</code><br />
<code>#include &quot;stm32wbxx_ll_pwr.h&quot;</code><br />
<code>#include &quot;stm32wbxx_ll_cortex.h&quot;</code><br />
<code>#include &quot;stm32wbxx_ll_utils.h&quot;</code><br />
<code>#include &quot;stm32wbxx_ll_hsem.h&quot;</code><br />
<code>#include &quot;stm32wbxx_ll_gpio.h&quot;</code><br />
<code>#include &quot;stm32wbxx_ll_rtc.h&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for hw_if.h:</div>
<div class="dyncontent">
<div class="center"><img src="hw__if_8h__incl.png" border="0" usemap="#aos-libs_2aos-core_2aos__ble_2hw__if_8h" alt=""/></div>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="hw__if_8h__dep__incl.png" border="0" usemap="#aos-libs_2aos-core_2aos__ble_2hw__if_8hdep" alt=""/></div>
<map name="aos-libs_2aos-core_2aos__ble_2hw__if_8hdep" id="aos-libs_2aos-core_2aos__ble_2hw__if_8hdep">
<area shape="rect" id="node2" href="app__conf_8h.html" title="Application configuration file for STM32WPAN Middleware. " alt="" coords="71,95,217,136"/>
<area shape="rect" id="node4" href="aos__tl__dbg__conf_8h.html" title="Debug configuration file for stm32wpan transport layer interface. " alt="" coords="177,184,333,225"/>
<area shape="rect" id="node3" href="aos__ble__conf_8h.html" title="Configuration file for BLE Middleware. " alt="" coords="5,184,152,225"/>
</map>
</div>
</div>
<p><a href="hw__if_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a2d49fad3a324fa94395feab5034173d1"><td class="memItemLeft" align="right" valign="top"><a id="a2d49fad3a324fa94395feab5034173d1"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>HW_TS_pTimerCb_t</b>) (void)</td></tr>
<tr class="separator:a2d49fad3a324fa94395feab5034173d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a90265ef03b989b92794b61848dbe4e81"><td class="memItemLeft" align="right" valign="top"><a id="a90265ef03b989b92794b61848dbe4e81"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>hw_uart_id_t</b> { <b>hw_uart1</b>, 
<b>hw_uart2</b>, 
<b>hw_lpuart1</b>
 }</td></tr>
<tr class="separator:a90265ef03b989b92794b61848dbe4e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56f41d2f7c51d139cd8d7d54f11002fd"><td class="memItemLeft" align="right" valign="top"><a id="a56f41d2f7c51d139cd8d7d54f11002fd"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>hw_status_t</b> { <b>hw_uart_ok</b>, 
<b>hw_uart_error</b>, 
<b>hw_uart_busy</b>, 
<b>hw_uart_to</b>
 }</td></tr>
<tr class="separator:a56f41d2f7c51d139cd8d7d54f11002fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbb5103d2d21f00d5906cdb8b7742378"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__if_8h.html#abbb5103d2d21f00d5906cdb8b7742378">HW_TS_InitMode_t</a> { <b>hw_ts_InitMode_Full</b>, 
<b>hw_ts_InitMode_Limited</b>
 }</td></tr>
<tr class="separator:abbb5103d2d21f00d5906cdb8b7742378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada8bd2cd1859456fee3bec6ce9e26fcd"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__if_8h.html#ada8bd2cd1859456fee3bec6ce9e26fcd">HW_TS_Mode_t</a> { <b>hw_ts_SingleShot</b>, 
<b>hw_ts_Repeated</b>
 }</td></tr>
<tr class="separator:ada8bd2cd1859456fee3bec6ce9e26fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae79a2e207e9a55efeed2364f0a51b811"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__if_8h.html#ae79a2e207e9a55efeed2364f0a51b811">HW_TS_ReturnStatus_t</a> { <b>hw_ts_Successful</b>, 
<b>hw_ts_Failed</b>
 }</td></tr>
<tr class="separator:ae79a2e207e9a55efeed2364f0a51b811"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4fac8082ae77d678c5ec31f42dd7bae8"><td class="memItemLeft" align="right" valign="top"><a id="a4fac8082ae77d678c5ec31f42dd7bae8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>HW_UART_Init</b> (hw_uart_id_t hw_uart_id)</td></tr>
<tr class="separator:a4fac8082ae77d678c5ec31f42dd7bae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a025b81aaf64bbc0f253816522c99a421"><td class="memItemLeft" align="right" valign="top"><a id="a025b81aaf64bbc0f253816522c99a421"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>HW_UART_Receive_IT</b> (hw_uart_id_t hw_uart_id, uint8_t *pData, uint16_t Size, void(*Callback)(void))</td></tr>
<tr class="separator:a025b81aaf64bbc0f253816522c99a421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f65b70a0c9e4a243ebdfcb8103a6245"><td class="memItemLeft" align="right" valign="top"><a id="a9f65b70a0c9e4a243ebdfcb8103a6245"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>HW_UART_Transmit_IT</b> (hw_uart_id_t hw_uart_id, uint8_t *pData, uint16_t Size, void(*Callback)(void))</td></tr>
<tr class="separator:a9f65b70a0c9e4a243ebdfcb8103a6245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c22e8482dedc51b6fbafa1234b8bc54"><td class="memItemLeft" align="right" valign="top"><a id="a1c22e8482dedc51b6fbafa1234b8bc54"></a>
hw_status_t&#160;</td><td class="memItemRight" valign="bottom"><b>HW_UART_Transmit</b> (hw_uart_id_t hw_uart_id, uint8_t *p_data, uint16_t size, uint32_t timeout)</td></tr>
<tr class="separator:a1c22e8482dedc51b6fbafa1234b8bc54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827150951641426436c3637896bd9960"><td class="memItemLeft" align="right" valign="top"><a id="a827150951641426436c3637896bd9960"></a>
hw_status_t&#160;</td><td class="memItemRight" valign="bottom"><b>HW_UART_Transmit_DMA</b> (hw_uart_id_t hw_uart_id, uint8_t *p_data, uint16_t size, void(*Callback)(void))</td></tr>
<tr class="separator:a827150951641426436c3637896bd9960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45979c1d0a6913bcc8ce2820aa0d47af"><td class="memItemLeft" align="right" valign="top"><a id="a45979c1d0a6913bcc8ce2820aa0d47af"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>HW_UART_Interrupt_Handler</b> (hw_uart_id_t hw_uart_id)</td></tr>
<tr class="separator:a45979c1d0a6913bcc8ce2820aa0d47af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a498a1ac1637012d0b3b4c74b1f3b212c"><td class="memItemLeft" align="right" valign="top"><a id="a498a1ac1637012d0b3b4c74b1f3b212c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>HW_UART_DMA_Interrupt_Handler</b> (hw_uart_id_t hw_uart_id)</td></tr>
<tr class="separator:a498a1ac1637012d0b3b4c74b1f3b212c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a005724bd5f5d5a421fb98aead33dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__if_8h.html#af4a005724bd5f5d5a421fb98aead33dc">HW_TS_Init</a> (<a class="el" href="hw__if_8h.html#abbb5103d2d21f00d5906cdb8b7742378">HW_TS_InitMode_t</a> TimerInitMode, RTC_HandleTypeDef *hrtc)</td></tr>
<tr class="memdesc:af4a005724bd5f5d5a421fb98aead33dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the timer server This API shall be called by the application before any timer is requested to the timer server. It configures the RTC module to be connected to the LSI input clock.  <a href="#af4a005724bd5f5d5a421fb98aead33dc">More...</a><br /></td></tr>
<tr class="separator:af4a005724bd5f5d5a421fb98aead33dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a42b4a5b750fc7ca4c140381735e75d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="hw__if_8h.html#ae79a2e207e9a55efeed2364f0a51b811">HW_TS_ReturnStatus_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__if_8h.html#a0a42b4a5b750fc7ca4c140381735e75d">HW_TS_Create</a> (uint32_t TimerProcessID, uint8_t *pTimerId, <a class="el" href="hw__if_8h.html#ada8bd2cd1859456fee3bec6ce9e26fcd">HW_TS_Mode_t</a> TimerMode, HW_TS_pTimerCb_t pTimerCallBack)</td></tr>
<tr class="memdesc:a0a42b4a5b750fc7ca4c140381735e75d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface to create a virtual timer The user shall call this API to create a timer. Once created, the timer is reserved to the module until it has been deleted. When creating a timer, the user shall specify the mode (single shot or repeated), the callback to be notified when the timer expires and a module ID to identify in the timer interrupt handler which module is concerned. In return, the user gets a timer ID to handle it.  <a href="#a0a42b4a5b750fc7ca4c140381735e75d">More...</a><br /></td></tr>
<tr class="separator:a0a42b4a5b750fc7ca4c140381735e75d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a074c5891343632fda3b0ebad42b64564"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__if_8h.html#a074c5891343632fda3b0ebad42b64564">HW_TS_Stop</a> (uint8_t TimerID)</td></tr>
<tr class="memdesc:a074c5891343632fda3b0ebad42b64564"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop a virtual timer This API may be used to stop a running timer. A timer which is stopped is move to the pending state. A pending timer may be restarted at any time with a different timeout value but the mode cannot be changed. Nothing is done when it is called to stop a timer which has been already stopped.  <a href="#a074c5891343632fda3b0ebad42b64564">More...</a><br /></td></tr>
<tr class="separator:a074c5891343632fda3b0ebad42b64564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5a2404f3ca4d38bfcfa19b26d921b0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__if_8h.html#ae5a2404f3ca4d38bfcfa19b26d921b0f">HW_TS_Start</a> (uint8_t TimerID, uint32_t timeout_ticks)</td></tr>
<tr class="memdesc:ae5a2404f3ca4d38bfcfa19b26d921b0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a virtual timer This API shall be used to start a timer. The timeout value is specified and may be different each time. When the timer is in the single shot mode, it will move to the pending state when it expires. The user may restart it at any time with a different timeout value. When the timer is in the repeated mode, it always stay in the running state. When the timer expires, it will be restarted with the same timeout value. This API shall not be called on a running timer.  <a href="#ae5a2404f3ca4d38bfcfa19b26d921b0f">More...</a><br /></td></tr>
<tr class="separator:ae5a2404f3ca4d38bfcfa19b26d921b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1020012c98fa0f1085910c3712538869"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__if_8h.html#a1020012c98fa0f1085910c3712538869">HW_TS_Delete</a> (uint8_t TimerID)</td></tr>
<tr class="memdesc:a1020012c98fa0f1085910c3712538869"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a virtual timer from the list This API should be used when a timer is not needed anymore by the user. A deleted timer is removed from the timer list managed by the timer server. It cannot be restarted again. The user has to go with the creation of a new timer if required and may get a different timer id.  <a href="#a1020012c98fa0f1085910c3712538869">More...</a><br /></td></tr>
<tr class="separator:a1020012c98fa0f1085910c3712538869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a438915fc276ab03daede51b18d8eefdf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__if_8h.html#a438915fc276ab03daede51b18d8eefdf">HW_TS_RTC_Wakeup_Handler</a> (void)</td></tr>
<tr class="memdesc:a438915fc276ab03daede51b18d8eefdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule the timer list on the timer interrupt handler This interrupt handler shall be called by the application in the RTC interrupt handler. This handler takes care of clearing all status flag required in the RTC and EXTI peripherals.  <a href="#a438915fc276ab03daede51b18d8eefdf">More...</a><br /></td></tr>
<tr class="separator:a438915fc276ab03daede51b18d8eefdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23a72a096e30fa51ad7f0519255b28b8"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__if_8h.html#a23a72a096e30fa51ad7f0519255b28b8">HW_TS_RTC_ReadLeftTicksToCount</a> (void)</td></tr>
<tr class="memdesc:a23a72a096e30fa51ad7f0519255b28b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of ticks to count before the interrupt This API returns the number of ticks left to be counted before an interrupt is generated by the Timer Server. This API may be used by the application for power management optimization. When the system enters low power mode, the mode selection is a tradeoff between the wakeup time where the CPU is running and the time while the CPU will be kept in low power mode before next wakeup. The deeper is the low power mode used, the longer is the wakeup time. The low power mode management considering wakeup time versus time in low power mode is implementation specific When the timer is disabled (No timer in the list), it returns 0xFFFF.  <a href="#a23a72a096e30fa51ad7f0519255b28b8">More...</a><br /></td></tr>
<tr class="separator:a23a72a096e30fa51ad7f0519255b28b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1641ac33ad9aae267d2a51e3a6b107"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__if_8h.html#a5f1641ac33ad9aae267d2a51e3a6b107">HW_TS_RTC_Int_AppNot</a> (uint32_t TimerProcessID, uint8_t TimerID, HW_TS_pTimerCb_t pTimerCallBack)</td></tr>
<tr class="memdesc:a5f1641ac33ad9aae267d2a51e3a6b107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify the application that a registered timer has expired This API shall be implemented by the user application. This API notifies the application that a timer expires. This API is running in the RTC Wakeup interrupt context. The application may implement an Operating System to change the context priority where the timer callback may be handled. This API provides the module ID to identify which module is concerned and to allow sending the information to the correct task.  <a href="#a5f1641ac33ad9aae267d2a51e3a6b107">More...</a><br /></td></tr>
<tr class="separator:a5f1641ac33ad9aae267d2a51e3a6b107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa37a3224cc7fb14624fd6c7d4f7da2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__if_8h.html#aaa37a3224cc7fb14624fd6c7d4f7da2c">HW_TS_RTC_CountUpdated_AppNot</a> (void)</td></tr>
<tr class="memdesc:aaa37a3224cc7fb14624fd6c7d4f7da2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify the application that the wakeupcounter has been updated This API should be implemented by the user application This API notifies the application that the counter has been updated. This is expected to be used along with the HW_TS_RTC_ReadLeftTicksToCount () API. It could be that the counter has been updated since the last call of HW_TS_RTC_ReadLeftTicksToCount () and before entering low power mode. This notification provides a way to the application to solve that race condition to reevaluate the counter value before entering low power mode.  <a href="#aaa37a3224cc7fb14624fd6c7d4f7da2c">More...</a><br /></td></tr>
<tr class="separator:aaa37a3224cc7fb14624fd6c7d4f7da2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Hardware Interface. </p>
<dl class="section author"><dt>Author</dt><dd>MCD Application Team </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd></dd></dl>
<p>Copyright (c) 2022 STMicroelectronics. All rights reserved.</p>
<p>This software is licensed under terms that can be found in the LICENSE file in the root directory of this software component. If no LICENSE file comes with this software, it is provided AS-IS. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="abbb5103d2d21f00d5906cdb8b7742378"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbb5103d2d21f00d5906cdb8b7742378">&#9670;&nbsp;</a></span>HW_TS_InitMode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="hw__if_8h.html#abbb5103d2d21f00d5906cdb8b7742378">HW_TS_InitMode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This setting is used when standby mode is supported. hw_ts_InitMode_Limited should be used when the device restarts from Standby Mode. In that case, the Timer Server does not re-initialized its context. Only the Hardware register which content has been lost is reconfigured Otherwise, hw_ts_InitMode_Full should be requested (Start from Power ON) and everything is re-initialized. </p>

</div>
</div>
<a id="ada8bd2cd1859456fee3bec6ce9e26fcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada8bd2cd1859456fee3bec6ce9e26fcd">&#9670;&nbsp;</a></span>HW_TS_Mode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="hw__if_8h.html#ada8bd2cd1859456fee3bec6ce9e26fcd">HW_TS_Mode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When a Timer is created as a SingleShot timer, it is not automatically restarted when the timeout occurs. However, the timer is kept reserved in the list and could be restarted at anytime with <a class="el" href="hw__if_8h.html#ae5a2404f3ca4d38bfcfa19b26d921b0f" title="Start a virtual timer This API shall be used to start a timer. The timeout value is specified and may...">HW_TS_Start()</a></p>
<p>When a Timer is created as a Repeated timer, it is automatically restarted when the timeout occurs. </p>

</div>
</div>
<a id="ae79a2e207e9a55efeed2364f0a51b811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae79a2e207e9a55efeed2364f0a51b811">&#9670;&nbsp;</a></span>HW_TS_ReturnStatus_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="hw__if_8h.html#ae79a2e207e9a55efeed2364f0a51b811">HW_TS_ReturnStatus_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>hw_ts_Successful is returned when a Timer has been successfully created with <a class="el" href="hw__if_8h.html#a0a42b4a5b750fc7ca4c140381735e75d" title="Interface to create a virtual timer The user shall call this API to create a timer. Once created, the timer is reserved to the module until it has been deleted. When creating a timer, the user shall specify the mode (single shot or repeated), the callback to be notified when the timer expires and a module ID to identify in the timer interrupt handler which module is concerned. In return, the user gets a timer ID to handle it. ">HW_TS_Create()</a>. Otherwise, hw_ts_Failed is returned. When hw_ts_Failed is returned, that means there are not enough free slots in the list to create a Timer. In that case, CFG_HW_TS_MAX_NBR_CONCURRENT_TIMER should be increased </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a0a42b4a5b750fc7ca4c140381735e75d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a42b4a5b750fc7ca4c140381735e75d">&#9670;&nbsp;</a></span>HW_TS_Create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="hw__if_8h.html#ae79a2e207e9a55efeed2364f0a51b811">HW_TS_ReturnStatus_t</a> HW_TS_Create </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>TimerProcessID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pTimerId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="hw__if_8h.html#ada8bd2cd1859456fee3bec6ce9e26fcd">HW_TS_Mode_t</a>&#160;</td>
          <td class="paramname"><em>TimerMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HW_TS_pTimerCb_t&#160;</td>
          <td class="paramname"><em>pTimerCallBack</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interface to create a virtual timer The user shall call this API to create a timer. Once created, the timer is reserved to the module until it has been deleted. When creating a timer, the user shall specify the mode (single shot or repeated), the callback to be notified when the timer expires and a module ID to identify in the timer interrupt handler which module is concerned. In return, the user gets a timer ID to handle it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TimerProcessID</td><td>This is an identifier provided by the user and returned in the callback to allow identification of the requester </td></tr>
    <tr><td class="paramname">pTimerId</td><td>Timer Id returned to the user to request operation (start, stop, delete) </td></tr>
    <tr><td class="paramname">TimerMode</td><td>Mode of the virtual timer (Single shot or repeated) </td></tr>
    <tr><td class="paramname">pTimerCallBack</td><td>Callback when the virtual timer expires </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">HW_TS_ReturnStatus_t</td><td>Return whether the creation is successful or not </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1020012c98fa0f1085910c3712538869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1020012c98fa0f1085910c3712538869">&#9670;&nbsp;</a></span>HW_TS_Delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HW_TS_Delete </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>TimerID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a virtual timer from the list This API should be used when a timer is not needed anymore by the user. A deleted timer is removed from the timer list managed by the timer server. It cannot be restarted again. The user has to go with the creation of a new timer if required and may get a different timer id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TimerID</td><td>The ID of the timer to remove from the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af4a005724bd5f5d5a421fb98aead33dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4a005724bd5f5d5a421fb98aead33dc">&#9670;&nbsp;</a></span>HW_TS_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HW_TS_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="hw__if_8h.html#abbb5103d2d21f00d5906cdb8b7742378">HW_TS_InitMode_t</a>&#160;</td>
          <td class="paramname"><em>TimerInitMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTC_HandleTypeDef *&#160;</td>
          <td class="paramname"><em>hrtc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the timer server This API shall be called by the application before any timer is requested to the timer server. It configures the RTC module to be connected to the LSI input clock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TimerInitMode</td><td>When the device restarts from Standby, it should request hw_ts_InitMode_Limited so that the Timer context is not re-initialized. Otherwise, hw_ts_InitMode_Full should be requested </td></tr>
    <tr><td class="paramname">hrtc</td><td>RTC Handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa37a3224cc7fb14624fd6c7d4f7da2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa37a3224cc7fb14624fd6c7d4f7da2c">&#9670;&nbsp;</a></span>HW_TS_RTC_CountUpdated_AppNot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HW_TS_RTC_CountUpdated_AppNot </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notify the application that the wakeupcounter has been updated This API should be implemented by the user application This API notifies the application that the counter has been updated. This is expected to be used along with the HW_TS_RTC_ReadLeftTicksToCount () API. It could be that the counter has been updated since the last call of HW_TS_RTC_ReadLeftTicksToCount () and before entering low power mode. This notification provides a way to the application to solve that race condition to reevaluate the counter value before entering low power mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f1641ac33ad9aae267d2a51e3a6b107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f1641ac33ad9aae267d2a51e3a6b107">&#9670;&nbsp;</a></span>HW_TS_RTC_Int_AppNot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HW_TS_RTC_Int_AppNot </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>TimerProcessID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>TimerID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HW_TS_pTimerCb_t&#160;</td>
          <td class="paramname"><em>pTimerCallBack</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notify the application that a registered timer has expired This API shall be implemented by the user application. This API notifies the application that a timer expires. This API is running in the RTC Wakeup interrupt context. The application may implement an Operating System to change the context priority where the timer callback may be handled. This API provides the module ID to identify which module is concerned and to allow sending the information to the correct task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TimerProcessID</td><td>The TimerProcessId associated with the timer when it has been created </td></tr>
    <tr><td class="paramname">TimerID</td><td>The TimerID of the expired timer </td></tr>
    <tr><td class="paramname">pTimerCallBack</td><td>The Callback associated with the timer when it has been created </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a23a72a096e30fa51ad7f0519255b28b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23a72a096e30fa51ad7f0519255b28b8">&#9670;&nbsp;</a></span>HW_TS_RTC_ReadLeftTicksToCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t HW_TS_RTC_ReadLeftTicksToCount </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of ticks to count before the interrupt This API returns the number of ticks left to be counted before an interrupt is generated by the Timer Server. This API may be used by the application for power management optimization. When the system enters low power mode, the mode selection is a tradeoff between the wakeup time where the CPU is running and the time while the CPU will be kept in low power mode before next wakeup. The deeper is the low power mode used, the longer is the wakeup time. The low power mode management considering wakeup time versus time in low power mode is implementation specific When the timer is disabled (No timer in the list), it returns 0xFFFF. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">The</td><td>number of ticks left to count </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a438915fc276ab03daede51b18d8eefdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a438915fc276ab03daede51b18d8eefdf">&#9670;&nbsp;</a></span>HW_TS_RTC_Wakeup_Handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HW_TS_RTC_Wakeup_Handler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule the timer list on the timer interrupt handler This interrupt handler shall be called by the application in the RTC interrupt handler. This handler takes care of clearing all status flag required in the RTC and EXTI peripherals. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae5a2404f3ca4d38bfcfa19b26d921b0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5a2404f3ca4d38bfcfa19b26d921b0f">&#9670;&nbsp;</a></span>HW_TS_Start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HW_TS_Start </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>TimerID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout_ticks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start a virtual timer This API shall be used to start a timer. The timeout value is specified and may be different each time. When the timer is in the single shot mode, it will move to the pending state when it expires. The user may restart it at any time with a different timeout value. When the timer is in the repeated mode, it always stay in the running state. When the timer expires, it will be restarted with the same timeout value. This API shall not be called on a running timer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TimerID</td><td>The ID Id of the timer to start </td></tr>
    <tr><td class="paramname">timeout_ticks</td><td>Number of ticks of the virtual timer (Maximum value is (0xFFFFFFFF-0xFFFF = 0xFFFF0000) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a074c5891343632fda3b0ebad42b64564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a074c5891343632fda3b0ebad42b64564">&#9670;&nbsp;</a></span>HW_TS_Stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HW_TS_Stop </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>TimerID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop a virtual timer This API may be used to stop a running timer. A timer which is stopped is move to the pending state. A pending timer may be restarted at any time with a different timeout value but the mode cannot be changed. Nothing is done when it is called to stop a timer which has been already stopped. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TimerID</td><td>Id of the timer to stop </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
